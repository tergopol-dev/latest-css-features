---
import Layout from "../../layouts/Layout.astro";
---

<Layout
  title="HD's Round Table: Nesting"
  mainNavConfiguration={{
    linkSource: "/nesting/example",
    linkTitle: "Example",
  }}
>
  <section class="container prose lg:prose-lg">
    <h1 class="text-4xl">Nesting</h1>
    <p>
      The CSS nesting module introduces a syntax for nesting selectors, allowing
      one style rule to be nested inside another, with the child rule's selector
      relative to the parent rule's selector. CSS nesting is different from CSS
      preprocessors like <a
        href="https://sass-lang.com/"
        rel="noopener noreferrer"
        target="_blank">Sass</a
      > because it is parsed by the browser instead of being pre-compiled by a CSS
      preprocessor.
    </p>
    <p>
      The CSS <code>&</code> nesting selector explicitly defines the relationship
      between parent and child rules when using <a
        href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting"
        rel="noopener noreferrer"
        target="_blank">CSS nesting</a
      >. It makes the nested child rule selectors relative to the parent
      element. The child rule selectors have the same
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity"
        rel="noopener noreferrer"
        target="_blank">specificity</a
      > weight as if they were within <a
        href="https://developer.mozilla.org/en-US/docs/Web/CSS/:is"
        rel="noopener noreferrer"
        target="_blank"><code>:is()</code></a
      >. Many CSS class naming conventions rely on nesting to concatenate or
      append selectors as if they were strings (e.g., <code is:raw
        >&--modifier { ... }</code
      >). However, this does not work in CSS nesting because the selectors are
      not treated as strings; they are treated as object references.
    </p>
  </section>
</Layout>
